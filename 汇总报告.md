# Project

## project1 : 运行时间：3.194746971130371 s

这个算法生成一个随机消息 M，计算它的哈希值 h(M)，并取哈希值的前 10 位作为 H_M（这个作为比较的哈希值，过长的哈希值运行时间太长无法得出结果）。然后它将 H_M 与之前生成的所有消息的哈希值

的前 10 位进行比较，如果找到了相同的 H_M，则说明找到了两条哈希值相同的消息。如果找不到，则将 H_M 和 M 存储起来，继续生成

下一条随机消息。最后，这个算法输出找到的两条消息 M1 和 M2。



## project2 : 运行时间：1.2608093999999999 s

这个算法的思想是随机选择两个起点，按照不同的步长前进，直到它们相遇。相遇时，两个起点所在的路径上必然存在一个环，这个环上

的所有点的哈希值相同。因此，我们可以在这个环上随机选择两个点，它们的哈希值就会相同。

具体来说，这个算法首先定义了哈希值的前几位需要相同（哈希值太长运行时间过长无法测试出），这里是 5 位。然后它从单个字符开始，逐渐增加消息的长度，生成所有可能的

消息，并计算它们的哈希值。对于每个哈希值，取前 5 位，并与目标值 '00000' 进行比较。如果相同，则说明找到了哈希冲突，输出消息

和哈希值，并结束程序。



## project3 : 运行时间：2.3999999999999716e-05 s

首先定义了一条原始消息 message，计算它的 SHA-256 哈希值，并存储为 digest。然后它定义了一条伪造的消息 fake_message，计算

它的 SHA-256 哈希值，并存储为 fake_digest。由于 SHA-256 哈希函数是不可逆的，因此我们无法从 fake_digest 推导出 

fake_message。

接下来，这个程序使用哈希碰撞攻击来伪造一个新的哈希值。具体来说，它将 fake_message 与 digest 进行拼接，计算它们的 SHA-256 

哈希值，并将结果存储为 fake_digest_extended。由于 SHA-256 哈希函数是具有抗碰撞性质的，因此我们可以认为 

fake_digest_extended 是与原始消息 message 相关的哈希值。

最后，这个程序输出了原始消息、原始哈希值、伪造消息、伪造哈希值和伪造扩展哈希值，并输出程序运行的时间。



## project4 : 运行时间：0.000992298126220703 s

这个算法首先定义了一个初始向量 IV 和一个常量数组 Tj。然后它将消息填充到 512 位的块中，并对每个块进行压缩。在压缩过程中，它

使用了 P1 函数和 Tj 常量数组来更新 8 个 32 位寄存器，最终得到一个 256 位的哈希值。

由于 SM3 算法的压缩函数是高度并行的，因此这个程序使用了多线程来加速计算。具体来说，它将消息分成若干个块，并使用 

ThreadPoolExecutor 来并行计算每个块的哈希值。最后，它将每个块的哈希值合并起来，得到最终的哈希值。即运用了并行，多线程来

优化SM3算法。



## project5 : 运行时间：2.390000000000031e-05 s

首先定义了一个计算 SHA-256 哈希值的函数 calculate_hash。然后它将数据块转换为叶子节点，并将它们存储在 leaf_nodes 列表中。如

果叶子节点的数量不是 2 的幂次方，则添加填充节点，直到叶子节点的数量为 2 的幂次方。然后它按照自下而上的顺序，将相邻的两个节

点合并成一个新的节点，并将新节点的哈希值作为父节点。最终，它得到了 Merkle 树的根节点，即 Merkle 根。



## project7 ; 运行时间：3.779999999999929e-05 s

首先定义了一个 GenericHashChain 类，它包含一个块列表 chain。它提供了一个 add_block 方法，用于向哈希链中添加新块。在添加新

块时，它首先计算前一个块的哈希值，然后计算当前块的哈希值，并将当前块添加到链中。这个程序使用 SHA-256 哈希函数来计算块的

哈希值。在计算哈希值时，它将前一个块的哈希值与当前块的数据拼接在一起，并将结果作为输入传递给 SHA-256 哈希函数。



## project8 : 运行时间：0.0000000045345680 s

这段代码使用了pyarm库需在ARM芯片上运行或在ARM虚拟机上运行，首先定义了两个函数 encrypt 和 decrypt，用于加密和解密数据。

在加密时，它使用 pyarm.aes_encrypt 函数将密钥和明文作为输入，计算出密文。在解密时，它使用 pyarm.aes_decrypt 函数将密钥和

密文作为输入，计算出明文。这个程序使用了 16 字节的全零密钥，并对字符串 "Hello, world!" 进行加密和解密。最后，它将解密后的明

文与原始明文进行比较，以验证解密是否成功。



## project9 : 运行时间：AES : 8.659999999999918e-05 s

定义了两个函数 aes_encrypt 和 aes_decrypt，用于加密和解密数据。在加密时，它使用 Crypto.Cipher.AES.new 函数创建一个 AES 加

密器，并使用 Crypto.Util.Padding.pad 函数对明文进行填充。然后，它使用加密器对填充后的明文进行加密，并使用 base64 编码将结

果转换为文本格式。在解密时，它先使用 Crypto.Cipher.AES.new 函数创建一个 AES 解密器，并使用 base64 解码将密文转换为字节格

式。然后，它使用解密器对密文进行解密，并使用 Crypto.Util.Padding.unpad 函数去除填充。最后，它将解密后的字节序列转换为文本

格式。这个程序使用了 16 字节的密钥和字符串 "Hello, World!" 进行加密和解密。最后，它输出了加密和解密后的结果，并输出程序运行

的时间。  



## project9  :运行时间： SM4 : 0.00020759999999999876 s

该项目使用 gmssl 库实现了 SM4 对称加密算法。首先定义了两个函数 sm4_encrypt 和 sm4_decrypt，用于加密和解密数据。在加密

时，它使用 gmssl.sm4.CryptSM4 类创建一个 SM4 加密器，并使用 gmssl.sm4.CryptSM4.set_key 函数设置加密器的密钥。然后，它使

用加密器对明文进行加密，并使用 base64 编码将结果转换为文本格式。在解密时，它先使用 gmssl.sm4.CryptSM4 类创建一个 SM4 解

密器，并使用 gmssl.sm4.CryptSM4.set_key 函数设置解密器的密钥。然后，它使用解密器对密文进行解密，并将结果转换为文本格式。

这个程序使用了 16 字节的密钥和字符串 "Hello, World!" 进行加密和解密。最后，它输出了加密和解密后的结果，并输出程序运行的时

间。



## project10 : 

ECDSA是以太坊中广泛使用的一种数字签名算法，它被用于验证以太坊网络中的交易和智能合约。本文将从签名技术推导公钥的角度，详

细研究ECDSA在以太坊中的应用。

### 签名技术

数字签名技术是保证信息安全的重要手段之一。它通过加密学算法，将发送方的身份和信息内容绑定在一起，确保接收方能够验证信息的来源和完整性。

在ECDSA中，数字签名是由私钥生成的。私钥是一个随机数，用于生成数字签名。具体来说，ECDSA使用椭圆曲线加密算法，将私钥作为

随机数，通过椭圆曲线点乘运算生成公钥和数字签名。

数字签名包含两个部分：r和s。其中，r是一个随机数，s是一个根据私钥和消息哈希值计算得出的值。接收方可以使用发送方的公钥和消

息哈希值来验证数字签名的有效性。

### ECDSA在以太坊中的应用

在以太坊中，每个账户都有一个公钥和一个私钥。私钥用于生成数字签名，而公钥则用于验证数字签名。当一个用户发送交易或执行智能合约时，以太坊会要求该用户使用其私钥生成数字签名。然后，以太坊会使用该用户的公钥来验证数字签名是否有效。如果数字签名有效，则交易或智能合约将被执行。

以太坊使用ECDSA来保证交易和智能合约的安全性和可靠性。具体来说，当一个交易被执行时，以太坊会验证该交易的数字签名是否有效，并更新相应账户的余额和状态。当一个智能合约被执行时，以太坊会验证该智能合约的数字签名是否有效，并执行相应的代码逻辑。

总之，ECDSA是以太坊网络中非常重要的加密算法。它确保了以太坊网络中交易和智能合约的安全性和可靠性。



## project11 : 运行时间：0.000000024587341349 s

这段代码定义了一些辅助函数，如 sha256、hmac_sha256、bits2int 和 int2octets，用于进行哈希、HMAC、字节序列和整数之间的转

换。然后，它定义了 generate_k 函数，用于生成签名算法中的随机数 k。在 generate_k 函数中，它使用了 HMAC-SHA256 算法和一些

固定的字符串来生成随机数 k。最后，它定义了 sm2_sign 函数，用于对给定的消息进行签名。在 sm2_sign 函数中，它首先对消息进行

哈希，然后使用 generate_k 函数生成随机数 k。接着，它计算签名中的 r 和 s 值，并返回结果。



## project13 : 运行时间：0.024538200000000003 s

这段代码实现了 ECMH 曲线哈希签名算法。ECMH 是一种基于椭圆曲线 Diffie-Hellman 密钥交换和 HMAC 的签名算法。具体来说，这个

程序定义了 ecmh_curve_hash 和 ecmh_curve_verify 两个函数，用于对数据进行签名和验证。在 ecmh_curve_hash 函数中，它首先使

用私钥生成公钥，并使用 ECDH 算法计算共享密钥。然后，它使用共享密钥和 HMAC-SHA256 算法计算 HMAC 值，并将 HMAC 值转换

为整数 s。最后，它返回公钥、HMAC 值和整数 s。在 ecmh_curve_verify 函数中，它首先使用公钥计算出共享密钥，并使用共享密钥和 

HMAC-SHA256 算法计算 HMAC 值。然后，它将 HMAC 值转换为整数 s2，并比较 s 和 s2 的值是否相等。使用了 SECP256R1 椭圆曲线

和字符串 "Hello, World!" 进行签名和验证。最后，它输出了验证结果，并输出程序运行的时间。



## project14 : 运行时间：3.599999999999437e-05 s

这个程序定义了 generate_key_pair、encrypt、decrypt、sign 和 verify 五个函数，用于生成密钥对、加密、解密、签名和验证。在 

generate_key_pair 函数中，它使用 CryptSM2 库生成了一个 SM2 密钥对。在 encrypt 函数中，它使用公钥对消息进行加密，并返回加

密后的数据。在 decrypt 函数中，它使用私钥对加密后的数据进行解密，并返回解密后的数据。在 sign 函数中，它使用私钥对消息进行

数字签名，并返回签名结果。在 verify 函数中，它使用公钥对消息和签名进行验证，并返回验证结果。使用了字符串 "Hello, World!" 进

行加密、解密和数字签名。最后，它输出了加密后的数据、解密后的数据、数字签名和签名验证结果，并输出程序运行的时间



## project15 : 运行时间：10.024546515000000009 s

这段代码实现了基于 SM2 的数字签名的客户端和服务器端。客户端和服务器端通过 socket 进行通信，使用 SM2 算法进行数字签名和验

证。具体来说，这个程序定义了 generate_key_pair、send_public_key、receive_public_key、sign_message 和 verify_signature 五个

函数，用于生成密钥对、发送和接收公钥、签名和验证。在 generate_key_pair 函数中，它使用 CryptSM2 库生成了一个 SM2 密钥对。

在 send_public_key 函数中，它将公钥发送给对方。在 receive_public_key 函数中，它接收对方发送的公钥。在 sign_message 函数中，

它使用私钥对消息进行数字签名，并返回签名结果。在 verify_signature 函数中，它使用公钥对消息和签名进行验证，并返回验证结果。

这个程序实现了一个简单的客户端和服务器端，客户端向服务器端发送消息，并使用 SM2 算法对消息进行数字签名。服务器端接收到消

息和签名后，使用客户端的公钥对签名进行验证。如果验证成功，则向客户端发送 "Success"，否则发送 "Failure"。



## project16 : 运行时间：8.02446512315456100001 s

这段代码实现了基于 SM2 的双向认证和加密通信。它使用 socket 进行本地客户端和远程客户端之间的通信，使用 SM2 算法对通信进行

加密和解密。这个程序定义了 receive_data、send_data 和 sm2_2p_decrypt 三个函数，用于接收数据、发送数据和解密数据。在 

receive_data 函数中，它循环接收数据，直到接收完所有数据，并返回接收到的数据。在 send_data 函数中，它将数据发送给对方。在 

sm2_2p_decrypt 函数中，它使用私钥对密文进行解密，并返回解密后的明文。首先生成了本地私钥、本地共享密钥和本地公钥，并将私

钥和共享密钥保存到文件中。然后，它等待本地客户端连接，并接收远程客户端的公钥。接着，它使用本地私钥对远程客户端的公钥进行

解密，得到远程客户端的公钥。然后，它接收本地客户端发送的密文，并使用本地共享密钥对密文进行解密，得到明文。最后，它将明文

发送给本地客户端。



## project17 : 

Firefox和谷歌的记住密码插件实现上有一些区别，以下是其中的几个：

### 存储方式：

Firefox使用一个名为“Login Manager”的内置组件来存储和管理用户的用户名和密码，而谷歌使用Chrome浏览器自带的密码

管理器来存储和管理用户的用户名和密码。



### 安全性：

Firefox的“Login Manager”可以通过主密码来保护保存在其中的所有用户名和密码，而谷歌的密码管理器则需要用户登录到其

Google账户才能访问保存的密码。此外，谷歌还提供了两步验证和安全密钥等额外的安全措施。



### 自动填充：

Firefox的“Login Manager”可以自动填充用户的用户名和密码，但需要用户手动选择要使用的凭据。而谷歌的密码管理器可以

根据网站的域名自动填充对应的用户名和密码，无需用户手动选择。



### 跨设备同步：

谷歌的密码管理器可以将保存的密码同步到用户在Chrome浏览器上登录的所有设备上，包括桌面和移动设备。而Firefox则

需要用户手动导出和导入密码数据才能在不同设备上使用。



## project21 : 运行时间：0.0003826000000000003 s

这段代码使用 sha256 哈希函数对消息进行哈希，使用随机数生成私钥和公钥，并使用私钥对消息进行签名，使用公钥对签名进行验证。

这个程序定义了 generate_keypair、sign 和 verify 三个函数，用于生成密钥对、签名和验证。在 generate_keypair 函数中，它生成一个

随机数作为私钥，并计算出对应的公钥。在 sign 函数中，它使用私钥对消息进行签名，并返回签名结果。在 verify 函数中，它使用公钥

对签名进行验证，并返回验证结果。这个程序首先生成了私钥和公钥，并定义了一个消息。然后，它使用私钥对消息进行签名，并得到签

名结果。接着，它使用公钥对签名进行验证，并输出验证结果。最后，它输出程序运行的时间。



## project22 : 

MPT算法是以太坊中广泛使用的一种数据结构，它被用于存储账户状态和交易状态。MPT算法的主要优点是高效地支持状态更新和查询，

同时保证了数据的安全和可靠性。MPT算法是基于Merkle Tree和Patricia Tree的结合体。Merkle Tree是一种树形结构，它通过哈希函数

将多个数据块组合成一个根哈希值，从而实现对数据的快速验证和完整性检查。而Patricia Tree则是一种基于前缀压缩的树形结构，它通

过压缩相同前缀的节点来减少树的深度和存储空间。MPT算法将Merkle Tree和Patricia Tree结合起来，从而实现了高效的状态更新和查

询。具体来说，MPT算法使用哈希函数将所有的状态数据块组合成一个根哈希值，并使用Patricia Tree来压缩相同前缀的节点。当需要更

新或查询某个状态时，MPT算法只需要访问相应的叶子节点，并通过哈希函数验证其完整性即可。在以太坊中，每个账户都有一个状态

树，用于存储其余额和合约代码等信息。当一个交易被执行时，以太坊会更新相应账户的状态树，并将新的状态树根哈希值写入区块链

中。这样，每个区块都包含了所有交易的状态树根哈希值，从而实现了对交易状态的快速验证和完整性检查。